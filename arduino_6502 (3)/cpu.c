#include <stdint.h>
#include <avr/pgmspace.h>


extern void printhex(uint16_t val);
extern void serout(uint8_t value);
//extern void ctone (uint16_t tone, uint16_t ms);
  
extern char threeHex[3][2];
extern int hexNum; 
extern int blitzMode;
    
#define NULL (void *) 0

#define RAM_SIZE 768 // 1536

//6502 defines
//#define UNDOCUMENTED //when this is defined, undocumented opcodes are handled.
                     //otherwise, they're simply treated as NOPs.

//#define USE_TIMING //slower, but allows you to specify number of cycles to run for exec6502 
                   //rather than simply a number of instructions. also uses a little more
                   //program memory when enabled.

#define FLAG_CARRY     0x01
#define FLAG_ZERO      0x02
#define FLAG_INTERRUPT 0x04
#define FLAG_DECIMAL   0x08
#define FLAG_BREAK     0x10
#define FLAG_CONSTANT  0x20
#define FLAG_OVERFLOW  0x40
#define FLAG_SIGN      0x80

#define BASE_STACK     0x100

#define saveaccum(n) a = (uint8_t)((n) & 0x00FF)


//flag modifier macros
#define setcarry() cpustatus |= FLAG_CARRY
#define clearcarry() cpustatus &= (~FLAG_CARRY)
#define setzero() cpustatus |= FLAG_ZERO
#define clearzero() cpustatus &= (~FLAG_ZERO)
#define setinterrupt() cpustatus |= FLAG_INTERRUPT
#define clearinterrupt() cpustatus &= (~FLAG_INTERRUPT)
#define setdecimal() cpustatus |= FLAG_DECIMAL
#define cleardecimal() cpustatus &= (~FLAG_DECIMAL)
#define setoverflow() cpustatus |= FLAG_OVERFLOW
#define clearoverflow() cpustatus &= (~FLAG_OVERFLOW)
#define setsign() cpustatus |= FLAG_SIGN
#define clearsign() cpustatus &= (~FLAG_SIGN)


//flag calculation macros
#define zerocalc(n) { if ((n) & 0x00FF) clearzero(); else setzero(); }

#define signcalc(n) { if ((n) & 0x0080) setsign(); else clearsign(); }

#define carrycalc(n) { if ((n) & 0xFF00) setcarry(); else clearcarry(); }

#define overflowcalc(n, m, o) { if (((n) ^ (uint16_t)(m)) & ((n) ^ (o)) & 0x0080) setoverflow(); else clearoverflow(); }


//6502 CPU registers
uint16_t pc;
uint8_t sp, a, x, y, cpustatus;


//helper variables
uint32_t instructions = 0; //keep track of total instructions executed
int32_t clockticks6502 = 0, clockgoal6502 = 0;
uint16_t oldpc, ea, reladdr, value, result;
uint8_t opcode, oldcpustatus, useaccum;

uint8_t RAM[RAM_SIZE];

prog_uchar BIOS[1393] PROGMEM = {  
        0xA9, 0x00, 0x85, 0xB7, 0x20, 0x54, 0xC4, 0xD8, 0xA2, 0xFF, 0x9A, 0xA2,
	0xC8, 0x86, 0xB2, 0x20, 0x78, 0xC3, 0x20, 0x49, 0xC4, 0xC9, 0x43, 0xD0,
	0x12, 0xA2, 0x1F, 0xBD, 0x14, 0xC5, 0x95, 0x50, 0xCA, 0x10, 0xF8, 0xA2,
	0x1B, 0x86, 0xDC, 0xA9, 0xCC, 0xD0, 0x19, 0xC9, 0x45, 0xD0, 0x0E, 0x20,
	0xC1, 0xC1, 0x38, 0xA9, 0x01, 0xE5, 0xB7, 0x85, 0xB7, 0xA9, 0xEE, 0xD0,
	0x07, 0xC9, 0x40, 0xD0, 0x0B, 0x20, 0xB5, 0xC2, 0x85, 0xFB, 0x85, 0xFA,
	0x85, 0xF9, 0xD0, 0xBB, 0xC9, 0x0D, 0xD0, 0x06, 0x20, 0x5B, 0xC2, 0x4C,
	0xFD, 0xC0, 0xC9, 0x41, 0xF0, 0x03, 0x4C, 0xF6, 0xC0, 0x4C, 0x00, 0xFF,
	0xA6, 0xB5, 0x30, 0x5C, 0xA5, 0xB0, 0xF0, 0x08, 0xE0, 0x08, 0xD0, 0x04,
	0xC5, 0xE6, 0xF0, 0x2E, 0xF6, 0xE3, 0xC9, 0x01, 0xD0, 0x02, 0xF6, 0xE3,
	0x50, 0x1E, 0xA0, 0x0F, 0xA5, 0xB1, 0xD9, 0x60, 0x00, 0xF0, 0x03, 0x88,
	0x10, 0xF8, 0xB9, 0x45, 0xC5, 0xD5, 0xE4, 0x90, 0x04, 0x94, 0xE6, 0x95,
	0xE4, 0x18, 0x08, 0x75, 0xE5, 0x95, 0xE5, 0x28, 0xE0, 0x04, 0xF0, 0x03,
	0x30, 0x31, 0x60, 0xA5, 0xE8, 0x85, 0xDD, 0xA9, 0x00, 0x85, 0xB5, 0x20,
	0x5B, 0xC2, 0x20, 0xC1, 0xC1, 0x20, 0x0F, 0xC1, 0x20, 0xC1, 0xC1, 0xA9,
	0x08, 0x85, 0xB5, 0x20, 0x18, 0xC1, 0x20, 0x41, 0xC2, 0x4C, 0x12, 0xC3,
	0xE0, 0xF9, 0xD0, 0x0B, 0xA5, 0x60, 0xC5, 0xB1, 0xD0, 0x04, 0xA9, 0x00,
	0x85, 0xB4, 0x60, 0x50, 0xFD, 0xA0, 0x07, 0xA5, 0xB1, 0xD9, 0x60, 0x00,
	0xF0, 0x05, 0x88, 0xF0, 0xF1, 0x10, 0xF6, 0xB9, 0x45, 0xC5, 0xD5, 0xE2,
	0x90, 0x02, 0x95, 0xE2, 0xC6, 0xB5, 0xA9, 0xFB, 0xC5, 0xB5, 0xF0, 0x03,
	0x20, 0x35, 0xC2, 0xE6, 0xB5, 0x60, 0xC9, 0x08, 0xB0, 0x12, 0x20, 0x02,
	0xC3, 0xA2, 0x1F, 0xB5, 0x50, 0xC5, 0xFA, 0xF0, 0x03, 0xCA, 0x10, 0xF7,
	0x86, 0xFB, 0x86, 0xB0, 0x4C, 0x07, 0xC0, 0xA2, 0x10, 0xA9, 0x00, 0x95,
	0xDE, 0xCA, 0x10, 0xFB, 0xA9, 0x10, 0x85, 0xB0, 0xC6, 0xB0, 0x10, 0x01,
	0x60, 0x20, 0x2E, 0xC2, 0xA4, 0xB0, 0xA2, 0x08, 0x86, 0xB6, 0xC0, 0x08,
	0x10, 0x41, 0xC0, 0x06, 0x10, 0x2E, 0xC0, 0x04, 0x10, 0x1F, 0xC0, 0x01,
	0xF0, 0x09, 0x10, 0x0E, 0x20, 0x9D, 0xC1, 0xD0, 0xFB, 0xF0, 0xD9, 0x20,
	0xAB, 0xC1, 0xD0, 0xFB, 0xF0, 0xD2, 0xA2, 0x04, 0x86, 0xB6, 0x20, 0xAB,
	0xC1, 0xD0, 0xFB, 0xF0, 0xC7, 0x20, 0xAB, 0xC1, 0xA5, 0xB6, 0xC9, 0x04,
	0xD0, 0xF7, 0xF0, 0xBC, 0xA2, 0x10, 0x86, 0xB6, 0x20, 0x9D, 0xC1, 0xA5,
	0xB6, 0xC9, 0x08, 0xD0, 0xF7, 0xF0, 0xAD, 0xA2, 0x06, 0x86, 0xB6, 0x20,
	0xD9, 0xC1, 0x50, 0x05, 0x30, 0x03, 0x20, 0x60, 0xC0, 0x20, 0x2E, 0xC2,
	0xC6, 0xB6, 0xA5, 0xB6, 0xC9, 0x05, 0xF0, 0xEB, 0x20, 0xD9, 0xC1, 0x70,
	0x8F, 0x30, 0x8D, 0x20, 0x60, 0xC0, 0xA5, 0xB1, 0x29, 0xF0, 0xC9, 0x20,
	0xF0, 0xEE, 0x4C, 0x1C, 0xC1, 0x20, 0xD9, 0xC1, 0x30, 0x03, 0x20, 0x60,
	0xC0, 0x20, 0x2E, 0xC2, 0xC6, 0xB6, 0x60, 0x20, 0xD9, 0xC1, 0x90, 0x02,
	0x50, 0xF9, 0x30, 0x07, 0x08, 0x20, 0x60, 0xC0, 0x28, 0x50, 0xF0, 0x20,
	0x2E, 0xC2, 0xC6, 0xB6, 0x60, 0xA2, 0x0F, 0x38, 0xB4, 0x60, 0xA9, 0x77,
	0xF5, 0x50, 0x95, 0x60, 0x94, 0x50, 0x38, 0xA9, 0x77, 0xF5, 0x50, 0x95,
	0x50, 0xCA, 0x10, 0xEB, 0x60, 0xA5, 0xB1, 0xA6, 0xB6, 0x18, 0x7D, 0x34,
	0xC5, 0x85, 0xB1, 0x29, 0x88, 0xD0, 0x42, 0xA5, 0xB1, 0xA2, 0x20, 0xCA,
	0x30, 0x0E, 0xD5, 0x50, 0xD0, 0xF9, 0xE0, 0x10, 0x30, 0x33, 0xA9, 0x7F,
	0x69, 0x01, 0x70, 0x01, 0xB8, 0xA5, 0xB5, 0x30, 0x24, 0xC9, 0x08, 0x10,
	0x20, 0x48, 0x08, 0xA9, 0xF9, 0x85, 0xB5, 0x85, 0xB4, 0x20, 0x5B, 0xC2,
	0x20, 0xC1, 0xC1, 0x20, 0x18, 0xC1, 0x20, 0x3E, 0xC2, 0x28, 0x68, 0x85,
	0xB5, 0xA5, 0xB4, 0x30, 0x04, 0x38, 0xA9, 0xFF, 0x60, 0x18, 0xA9, 0x00,
	0x60, 0xA9, 0xFF, 0x18, 0xB8, 0x60, 0xA6, 0xB0, 0xB5, 0x50, 0x85, 0xB1,
	0x60, 0x20, 0x5B, 0xC2, 0x20, 0xC1, 0xC1, 0x20, 0x18, 0xC1, 0x20, 0xC1,
	0xC1, 0xBA, 0x86, 0xB3, 0xA6, 0xB2, 0x9A, 0x68, 0x85, 0xB6, 0x68, 0x85,
	0xB0, 0xAA, 0x68, 0x95, 0x50, 0x68, 0xAA, 0x68, 0x85, 0xB1, 0x95, 0x50,
	0x4C, 0x80, 0xC2, 0xBA, 0x86, 0xB3, 0xA6, 0xB2, 0x9A, 0xA5, 0xB1, 0x48,
	0xA8, 0xA2, 0x1F, 0xD5, 0x50, 0xF0, 0x03, 0xCA, 0x10, 0xF9, 0xA9, 0xCC,
	0x95, 0x50, 0x8A, 0x48, 0xA6, 0xB0, 0xB5, 0x50, 0x94, 0x50, 0x48, 0x8A,
	0x48, 0xA5, 0xB6, 0x48, 0xBA, 0x86, 0xB2, 0xA6, 0xB3, 0x9A, 0x60, 0xA6,
	0xE4, 0xEC, 0x45, 0xC5, 0xD0, 0x04, 0xA9, 0x00, 0xF0, 0x0A, 0xA6, 0xE3,
	0xD0, 0x06, 0xA6, 0xEE, 0xD0, 0x02, 0xA9, 0xFF, 0xA2, 0x04, 0x86, 0xB5,
	0xC5, 0xFA, 0x90, 0x0C, 0xF0, 0x0A, 0x85, 0xFA, 0xA5, 0xB0, 0x85, 0xFB,
	0xA5, 0xB1, 0x85, 0xF9, 0xA9, 0x2E, 0x4C, 0x60, 0xC4, 0xA6, 0xDC, 0x30,
	0x1C, 0xA5, 0xF9, 0xDD, 0x55, 0xC5, 0xD0, 0x11, 0xCA, 0xBD, 0x55, 0xC5,
	0x85, 0xFB, 0xCA, 0xBD, 0x55, 0xC5, 0x85, 0xF9, 0xCA, 0x86, 0xDC, 0xD0,
	0x1C, 0xA9, 0xFF, 0x85, 0xDC, 0xA2, 0x0C, 0x86, 0xB5, 0x86, 0xFA, 0xA2,
	0x14, 0x20, 0x11, 0xC1, 0xA2, 0x04, 0x86, 0xB5, 0x20, 0x0F, 0xC1, 0xA6,
	0xFA, 0xE0, 0x0F, 0x90, 0x12, 0xA6, 0xFB, 0xB5, 0x50, 0x85, 0xFA, 0x86,
	0xB0, 0xA5, 0xF9, 0x85, 0xB1, 0x20, 0x5B, 0xC2, 0x4C, 0x07, 0xC0, 0xA9,
	0xFF, 0x60, 0xA2, 0x04, 0x06, 0xF9, 0x26, 0xFA, 0xCA, 0xD0, 0xF9, 0x05,
	0xF9, 0x85, 0xF9, 0x85, 0xB1, 0x60, 0x18, 0xA9, 0x80, 0x65, 0xEB, 0x65,
	0xEC, 0x65, 0xED, 0x65, 0xE1, 0x65, 0xDF, 0x38, 0xE5, 0xF0, 0xE5, 0xF1,
	0xE5, 0xE2, 0xE5, 0xE0, 0xE5, 0xDE, 0xE5, 0xEF, 0xE5, 0xE3, 0xB0, 0x02,
	0xA9, 0x00, 0x4A, 0x18, 0x69, 0x40, 0x65, 0xEC, 0x65, 0xED, 0x38, 0xE5,
	0xE4, 0x4A, 0x18, 0x69, 0x90, 0x65, 0xDD, 0x65, 0xDD, 0x65, 0xDD, 0x65,
	0xDD, 0x65, 0xE1, 0x38, 0xE5, 0xE4, 0xE5, 0xE4, 0xE5, 0xE5, 0xE5, 0xE5,
	0xE5, 0xE0, 0xA6, 0xB1, 0xE0, 0x33, 0xF0, 0x16, 0xE0, 0x34, 0xF0, 0x12,
	0xE0, 0x22, 0xF0, 0x0E, 0xE0, 0x25, 0xF0, 0x0A, 0xA6, 0xB0, 0xF0, 0x09,
	0xB4, 0x50, 0xC0, 0x10, 0x10, 0x03, 0x18, 0x69, 0x02, 0x4C, 0x87, 0xC2,
	0x20, 0x17, 0xC4, 0x20, 0x3B, 0xC4, 0x20, 0x22, 0xC4, 0xA0, 0x00, 0x20,
	0xE9, 0xC3, 0xA9, 0x7C, 0x20, 0x60, 0xC4, 0xA2, 0x1F, 0x98, 0xD5, 0x50,
	0xF0, 0x40, 0xCA, 0x10, 0xF8, 0x98, 0x29, 0x01, 0x85, 0xFC, 0x98, 0x4A,
	0x4A, 0x4A, 0x4A, 0x29, 0x01, 0x18, 0x65, 0xFC, 0x29, 0x01, 0xF0, 0x03,
	0xA9, 0x2A, 0x2C, 0xA9, 0x20, 0x20, 0x60, 0xC4, 0x20, 0x60, 0xC4, 0xC8,
	0x98, 0x29, 0x08, 0xF0, 0xCD, 0xA9, 0x7C, 0x20, 0x60, 0xC4, 0x20, 0x34,
	0xC4, 0x20, 0x17, 0xC4, 0x20, 0xE9, 0xC3, 0x18, 0x98, 0x69, 0x08, 0xA8,
	0xC0, 0x80, 0xF0, 0x2B, 0xD0, 0xB4, 0xA5, 0xB7, 0xF0, 0x05, 0xBD, 0xD3,
	0xC4, 0xD0, 0x03, 0xBD, 0xC3, 0xC4, 0x20, 0x60, 0xC4, 0xBD, 0xF3, 0xC4,
	0x20, 0x60, 0xC4, 0xD0, 0xCA, 0x8A, 0x48, 0xA2, 0x19, 0xA9, 0x2D, 0x20,
	0x60, 0xC4, 0xCA, 0xD0, 0xFA, 0x68, 0xAA, 0x20, 0x17, 0xC4, 0x60, 0x20,
	0x22, 0xC4, 0xA5, 0xFB, 0x20, 0x64, 0xC4, 0xA9, 0x20, 0x20, 0x60, 0xC4,
	0xA5, 0xFA, 0x20, 0x64, 0xC4, 0xA9, 0x20, 0x20, 0x60, 0xC4, 0xA5, 0xF9,
	0x20, 0x64, 0xC4, 0xA9, 0x0D, 0x20, 0x60, 0xC4, 0xA9, 0x0A, 0x20, 0x60,
	0xC4, 0x60, 0xA2, 0x00, 0xA9, 0x20, 0x20, 0x60, 0xC4, 0x8A, 0x20, 0x64,
	0xC4, 0xE8, 0xE0, 0x08, 0xD0, 0xF2, 0xF0, 0xE3, 0x98, 0x29, 0x70, 0x20,
	0x64, 0xC4, 0x60, 0xA2, 0x00, 0xBD, 0x8A, 0xC4, 0xF0, 0x06, 0x20, 0x60,
	0xC4, 0xE8, 0xD0, 0xF5, 0x60, 0xA9, 0x3F, 0x20, 0x60, 0xC4, 0x20, 0x55,
	0xC4, 0x29, 0x4F, 0x60, 0x60, 0xAD, 0x03, 0xF0, 0xC5, 0x01, 0xD0, 0xF9,
	0xAD, 0x04, 0xF0, 0x60, 0x8D, 0x01, 0xF0, 0x60, 0x48, 0x4A, 0x4A, 0x4A,
	0x4A, 0x20, 0x6D, 0xC4, 0x68, 0x29, 0x0F, 0x84, 0xFF, 0xA8, 0xB9, 0x7A,
	0xC4, 0xA4, 0xFF, 0x4C, 0x60, 0xC4, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35,
	0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x4D, 0x69,
	0x63, 0x72, 0x6F, 0x43, 0x68, 0x65, 0x73, 0x73, 0x20, 0x28, 0x63, 0x29,
	0x20, 0x31, 0x39, 0x39, 0x36, 0x2D, 0x32, 0x30, 0x30, 0x35, 0x20, 0x50,
	0x65, 0x74, 0x65, 0x72, 0x20, 0x4A, 0x65, 0x6E, 0x6E, 0x69, 0x6E, 0x67,
	0x73, 0x2C, 0x20, 0x77, 0x77, 0x77, 0x2E, 0x62, 0x65, 0x6E, 0x6C, 0x6F,
	0x2E, 0x63, 0x6F, 0x6D, 0x0D, 0x0A, 0x00, 0x57, 0x57, 0x57, 0x57, 0x57,
	0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x42,
	0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42,
	0x42, 0x42, 0x42, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57,
	0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x57, 0x4B, 0x51, 0x52, 0x52, 0x42,
	0x42, 0x4E, 0x4E, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x50, 0x4B,
	0x51, 0x52, 0x52, 0x42, 0x42, 0x4E, 0x4E, 0x50, 0x50, 0x50, 0x50, 0x50,
	0x50, 0x50, 0x50, 0x00, 0x03, 0x04, 0x00, 0x07, 0x02, 0x05, 0x01, 0x06,
	0x10, 0x17, 0x11, 0x16, 0x12, 0x15, 0x14, 0x13, 0x73, 0x74, 0x70, 0x77,
	0x72, 0x75, 0x71, 0x76, 0x60, 0x67, 0x61, 0x66, 0x62, 0x65, 0x64, 0x63,
	0x00, 0xF0, 0xFF, 0x01, 0x10, 0x11, 0x0F, 0xEF, 0xF1, 0xDF, 0xE1, 0xEE,
	0xF2, 0x12, 0x0E, 0x1F, 0x21, 0x0B, 0x0A, 0x06, 0x06, 0x04, 0x04, 0x04,
	0x04, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x99, 0x25, 0x0B,
	0x25, 0x01, 0x00, 0x33, 0x25, 0x07, 0x36, 0x34, 0x0D, 0x34, 0x34, 0x0E,
	0x52, 0x25, 0x0D, 0x45, 0x35, 0x04, 0x55, 0x22, 0x06, 0x43, 0x33, 0x0F,
	0xCC
};

//Top 256 bytes in 6502 memory map. Not really used anymore, junk!
prog_uchar BIOStop[256] PROGMEM = {
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xD8,0xA2,0xFF,0x9A,
	0xA0,0x1C,0xB9,0xBB,0xFF,0x99,0x04,0x02,0x88,0xD0,0xF7,
	0xB9,0xD8,0xFF,0xF0,0x06,0x20,0xED,0xE0,0xC8,0xD0,0xF5,
	0x20,0xEA,0xE0,0x90,0xFB,0x29,0xDF,0xC9,0x57,0xF0,0x07,
	0xC9,0x43,0xD0,0xD7,0x4C,0x00,0xC0,0x4C,0x00,0x00,0x8D,
	0x01,0xF0,0x60,0xAD,0x04,0xF0,0xF0,0x02,0x38,0x60,0x18,
	0x60,0xB3,0xFF,0xAF,0xFF,0xBB,0xFF,0xBB,0xFF,0x48,0xA5,
	0xDF,0x4A,0x05,0xDF,0x85,0xDF,0x68,0x40,0x48,0xA5,0xDC,
	0x4A,0x05,0xDC,0x85,0xDC,0x68,0x40,0x0D,0x0A,0x36,0x35,
	0x30,0x32,0x20,0x45,0x68,0x42,0x41,0x53,0x49,0x43,0x20,
	0x5B,0x43,0x5D,0x6F,0x6C,0x64,0x2F,0x5B,0x57,0x5D,0x61,
	0x72,0x6D,0x20,0x3F,0x00,0x00,0x00,0x00,0x17,0x02,0x80,
	0xFF,0x0D,0x02
};



uint8_t read6502(uint16_t address) {
  uint16_t BIOSaddr;
  uint8_t tempval = 0;
//uint8_t hexNum=1;                   // OV

  if (address == 0xF004) 
  { //EhBASIC simulated ASIC input
    tempval = getkey();
    clearkey();
    
    // ugly hack: if the user presses 'W', that means he wants to enable Blitz mode. 
    // It's ignored by 6502 microchess, just intercept it here.
    if (tempval==0x57) // 'W'
    {
      if (blitzMode==1) (blitzMode=0);
      else              (blitzMode=1);
      serout('>');
      serout( (blitzMode==1)?'B':'N' );
      serout('<');
    }
    // ------------------------------------------------------------------------------

    return(tempval);
  }

  if (address == 0xF003) 
  { //added simulated ASIC input 0=no key press, 1 = key press ready to be read by getkey    
    _put2char(threeHex[hexNum][0], threeHex[hexNum][1]);	showMatrix(1);
    tempval = keyready();    
    return(tempval);
  }

  if (address >= 0xC000) {
    BIOSaddr = address - 0xC000;
    
    // intercept C202: Blitz mode should return 0 instead of 8
    // This is the Blitz mode hack from the microchess manual.
    // we just override the byte code from the memory array...
    if (BIOSaddr == 0x0202) 
      if (blitzMode==1)
        return((uint8_t) 0x00);
    // -------------------------------------------------------
    
    if (BIOSaddr < 0x2900) return(pgm_read_byte_near(BIOS + BIOSaddr));
    if (BIOSaddr >= 0x3F00) return(pgm_read_byte_near(BIOStop + BIOSaddr - 0x3F00));
  }
  
  if (address < RAM_SIZE) return(RAM[address]);
  return(0);
}

void write6502(uint16_t address, uint8_t value) {

  if (address < RAM_SIZE) 
    RAM[address] = value;
  else if (address == 0xF001)
    serout(value);  // simulated UART output
  else 
    serout('%'); //ERROR illegal write
}

//a few general functions used by various other functions
void push16(uint16_t pushval) {
    write6502(BASE_STACK + sp, (pushval >> 8) & 0xFF);
    write6502(BASE_STACK + ((sp - 1) & 0xFF), pushval & 0xFF);
    sp -= 2;
}

void push8(uint8_t pushval) {
    write6502(BASE_STACK + sp--, pushval);
}

uint16_t pull16() {
    uint16_t temp16;
    temp16 = read6502(BASE_STACK + ((sp + 1) & 0xFF)) | ((uint16_t)read6502(BASE_STACK + ((sp + 2) & 0xFF)) << 8);
    sp += 2;
    return(temp16);
}

uint8_t pull8() {
    return (read6502(BASE_STACK + ++sp));
}

void reset6502() {
    //    pc = (uint16_t)read6502(0xFFFC) | ((uint16_t)read6502(0xFFFD) << 8);
    pc = (uint16_t)0xC000; // microchess is booted straight from its 0xC000 entry point, we don't need to boot from the FFFc/D address.
    a = 0;
    x = 0;
    y = 0;
    sp = 0xFD;
    cpustatus |= FLAG_CONSTANT;
}

//addressing mode functions, calculates effective addresses
void imp() { //implied
}

void acc() { //accumulator
  useaccum = 1;
}

void imm() { //immediate
    ea = pc++;
}

void zp() { //zero-page
    ea = (uint16_t)read6502((uint16_t)pc++);
}

void zpx() { //zero-page,X
    ea = ((uint16_t)read6502((uint16_t)pc++) + (uint16_t)x) & 0xFF; //zero-page wraparound
}

void zpy() { //zero-page,Y
    ea = ((uint16_t)read6502((uint16_t)pc++) + (uint16_t)y) & 0xFF; //zero-page wraparound
}

void rel() { //relative for branch ops (8-bit immediate value, sign-extended)
    reladdr = (uint16_t)read6502(pc++);
    if (reladdr & 0x80) reladdr |= 0xFF00;
}

void abso() { //absolute
    ea = (uint16_t)read6502(pc) | ((uint16_t)read6502(pc+1) << 8);
    pc += 2;
}

void absx() { //absolute,X
    uint16_t startpage;
    ea = ((uint16_t)read6502(pc) | ((uint16_t)read6502(pc+1) << 8));
    startpage = ea & 0xFF00;
    ea += (uint16_t)x;

    pc += 2;
}

void absy() { //absolute,Y
    uint16_t startpage;
    ea = ((uint16_t)read6502(pc) | ((uint16_t)read6502(pc+1) << 8));
    startpage = ea & 0xFF00;
    ea += (uint16_t)y;

    pc += 2;
}

void ind() { //indirect
    uint16_t eahelp, eahelp2;
    eahelp = (uint16_t)read6502(pc) | (uint16_t)((uint16_t)read6502(pc+1) << 8);
    eahelp2 = (eahelp & 0xFF00) | ((eahelp + 1) & 0x00FF); //replicate 6502 page-boundary wraparound bug
    ea = (uint16_t)read6502(eahelp) | ((uint16_t)read6502(eahelp2) << 8);
    pc += 2;
}

void indx() { // (indirect,X)
    uint16_t eahelp;
    eahelp = (uint16_t)(((uint16_t)read6502(pc++) + (uint16_t)x) & 0xFF); //zero-page wraparound for table pointer
    ea = (uint16_t)read6502(eahelp & 0x00FF) | ((uint16_t)read6502((eahelp+1) & 0x00FF) << 8);
}

void indy() { // (indirect),Y
    uint16_t eahelp, eahelp2, startpage;
    eahelp = (uint16_t)read6502(pc++);
    eahelp2 = (eahelp & 0xFF00) | ((eahelp + 1) & 0x00FF); //zero-page wraparound
    ea = (uint16_t)read6502(eahelp) | ((uint16_t)read6502(eahelp2) << 8);
    startpage = ea & 0xFF00;
    ea += (uint16_t)y;

}

static uint16_t getvalue() {
    if (useaccum) return((uint16_t)a);
        else return((uint16_t)read6502(ea));
}

static uint16_t getvalue16() {
    return((uint16_t)read6502(ea) | ((uint16_t)read6502(ea+1) << 8));
}

void putvalue(uint16_t saveval) {
    if (useaccum) a = (uint8_t)(saveval & 0x00FF);
        else write6502(ea, (saveval & 0x00FF));
}


//instruction handler functions
void adc() {
    value = getvalue();
    result = (uint16_t)a + value + (uint16_t)(cpustatus & FLAG_CARRY);
   
    carrycalc(result);
    zerocalc(result);
    overflowcalc(result, a, value);
    signcalc(result);
    
    #ifndef NES_CPU
    if (cpustatus & FLAG_DECIMAL) {
        clearcarry();
        
        if ((a & 0x0F) > 0x09) {
            a += 0x06;
        }
        if ((a & 0xF0) > 0x90) {
            a += 0x60;
            setcarry();
        }
        
        clockticks6502++;
    }
    #endif
   
    saveaccum(result);
}

void op_and() {
    value = getvalue();
    result = (uint16_t)a & value;
   
    zerocalc(result);
    signcalc(result);
   
    saveaccum(result);
}

void asl() {
    value = getvalue();
    result = value << 1;

    carrycalc(result);
    zerocalc(result);
    signcalc(result);
   
    putvalue(result);
}

void bcc() {
    if ((cpustatus & FLAG_CARRY) == 0) {
        oldpc = pc;
        pc += reladdr;
        if ((oldpc & 0xFF00) != (pc & 0xFF00)) clockticks6502 += 2; //check if jump crossed a page boundary
            else clockticks6502++;
    }
}

void bcs() {
    if ((cpustatus & FLAG_CARRY) == FLAG_CARRY) {
        oldpc = pc;
        pc += reladdr;
        if ((oldpc & 0xFF00) != (pc & 0xFF00)) clockticks6502 += 2; //check if jump crossed a page boundary
            else clockticks6502++;
    }
}

void beq() {
    if ((cpustatus & FLAG_ZERO) == FLAG_ZERO) {
        oldpc = pc;
        pc += reladdr;
        if ((oldpc & 0xFF00) != (pc & 0xFF00)) clockticks6502 += 2; //check if jump crossed a page boundary
            else clockticks6502++;
    }
}

void op_bit() {
    value = getvalue();
    result = (uint16_t)a & value;
   
    zerocalc(result);
    cpustatus = (cpustatus & 0x3F) | (uint8_t)(value & 0xC0);
}

void bmi() {
    if ((cpustatus & FLAG_SIGN) == FLAG_SIGN) {
        oldpc = pc;
        pc += reladdr;
        if ((oldpc & 0xFF00) != (pc & 0xFF00)) clockticks6502 += 2; //check if jump crossed a page boundary
            else clockticks6502++;
    }
}

void bne() {
    if ((cpustatus & FLAG_ZERO) == 0) {
        oldpc = pc;
        pc += reladdr;
        if ((oldpc & 0xFF00) != (pc & 0xFF00)) clockticks6502 += 2; //check if jump crossed a page boundary
            else clockticks6502++;
    }
}

void bpl() {
    if ((cpustatus & FLAG_SIGN) == 0) {
        oldpc = pc;
        pc += reladdr;
        if ((oldpc & 0xFF00) != (pc & 0xFF00)) clockticks6502 += 2; //check if jump crossed a page boundary
            else clockticks6502++;
    }
}

void brk() {
    pc++;
    push16(pc); //push next instruction address onto stack
    push8(cpustatus | FLAG_BREAK); //push CPU cpustatus to stack
    setinterrupt(); //set interrupt flag
    pc = (uint16_t)read6502(0xFFFE) | ((uint16_t)read6502(0xFFFF) << 8);
}

void bvc() {
    if ((cpustatus & FLAG_OVERFLOW) == 0) {
        oldpc = pc;
        pc += reladdr;
        if ((oldpc & 0xFF00) != (pc & 0xFF00)) clockticks6502 += 2; //check if jump crossed a page boundary
            else clockticks6502++;
    }
}

void bvs() {
    if ((cpustatus & FLAG_OVERFLOW) == FLAG_OVERFLOW) {
        oldpc = pc;
        pc += reladdr;
        if ((oldpc & 0xFF00) != (pc & 0xFF00)) clockticks6502 += 2; //check if jump crossed a page boundary
            else clockticks6502++;
    }
}

void clc() {
    clearcarry();
}

void cld() {
    cleardecimal();
}

void cli() {
    clearinterrupt();
}

void clv() {
    clearoverflow();
}

void cmp() {
    value = getvalue();
    result = (uint16_t)a - value;
   
    if (a >= (uint8_t)(value & 0x00FF)) setcarry();
        else clearcarry();
    if (a == (uint8_t)(value & 0x00FF)) setzero();
        else clearzero();
    signcalc(result);
}

void cpx() {
    value = getvalue();
    result = (uint16_t)x - value;
   
    if (x >= (uint8_t)(value & 0x00FF)) setcarry();
        else clearcarry();
    if (x == (uint8_t)(value & 0x00FF)) setzero();
        else clearzero();
    signcalc(result);
}

void cpy() {
    value = getvalue();
    result = (uint16_t)y - value;
   
    if (y >= (uint8_t)(value & 0x00FF)) setcarry();
        else clearcarry();
    if (y == (uint8_t)(value & 0x00FF)) setzero();
        else clearzero();
    signcalc(result);
}

void dec() {
    value = getvalue();
    result = value - 1;
   
    zerocalc(result);
    signcalc(result);
   
    putvalue(result);
}

void dex() {
    x--;
   
    zerocalc(x);
    signcalc(x);
}

void dey() {
    y--;
   
    zerocalc(y);
    signcalc(y);
}

void eor() {
    value = getvalue();
    result = (uint16_t)a ^ value;
   
    zerocalc(result);
    signcalc(result);
   
    saveaccum(result);
}

void inc() {
    value = getvalue();
    result = value + 1;
   
    zerocalc(result);
    signcalc(result);
   
    putvalue(result);
}

void inx() {
    x++;
   
    zerocalc(x);
    signcalc(x);
}

void iny() {
    y++;
   
    zerocalc(y);
    signcalc(y);
}

void jmp() {
    pc = ea;
}

void jsr() {
    push16(pc - 1);
    pc = ea;
}

void lda() {
    value = getvalue();
    a = (uint8_t)(value & 0x00FF);
   
    zerocalc(a);
    signcalc(a);
}

void ldx() {
    value = getvalue();
    x = (uint8_t)(value & 0x00FF);
   
    zerocalc(x);
    signcalc(x);
}

void ldy() {
    value = getvalue();
    y = (uint8_t)(value & 0x00FF);
   
    zerocalc(y);
    signcalc(y);
}

void lsr() {
    value = getvalue();
    result = value >> 1;
   
    if (value & 1) setcarry();
        else clearcarry();
    zerocalc(result);
    signcalc(result);
   
    putvalue(result);
}

void nop() {
}

void ora() {
    value = getvalue();
    result = (uint16_t)a | value;
   
    zerocalc(result);
    signcalc(result);
   
    saveaccum(result);
}

void pha() {
    push8(a);
}

void php() {
    push8(cpustatus | FLAG_BREAK);
}

void pla() {
    a = pull8();
   
    zerocalc(a);
    signcalc(a);
}

void plp() {
    cpustatus = pull8() | FLAG_CONSTANT;
}

void rol() {
    value = getvalue();
    result = (value << 1) | (cpustatus & FLAG_CARRY);
   
    carrycalc(result);
    zerocalc(result);
    signcalc(result);
   
    putvalue(result);
}

void ror() {
    value = getvalue();
    result = (value >> 1) | ((cpustatus & FLAG_CARRY) << 7);
   
    if (value & 1) setcarry();
        else clearcarry();
    zerocalc(result);
    signcalc(result);
   
    putvalue(result);
}

void rti() {
    cpustatus = pull8();
    value = pull16();
    pc = value;
}

void rts() {
    value = pull16();
    pc = value + 1;
}

void sbc() {
    value = getvalue() ^ 0x00FF;
    result = (uint16_t)a + value + (uint16_t)(cpustatus & FLAG_CARRY);
   
    carrycalc(result);
    zerocalc(result);
    overflowcalc(result, a, value);
    signcalc(result);

    #ifndef NES_CPU
    if (cpustatus & FLAG_DECIMAL) {
        clearcarry();
        
        a -= 0x66;
        if ((a & 0x0F) > 0x09) {
            a += 0x06;
        }
        if ((a & 0xF0) > 0x90) {
            a += 0x60;
            setcarry();
        }
        
        clockticks6502++;
    }
    #endif
   
    saveaccum(result);
}

void sec() {
    setcarry();
}

void sed() {
    setdecimal();
}

void sei() {
    setinterrupt();
}

void sta() {
    putvalue(a);
}

void stx() {
    putvalue(x);
}

void sty() {
    putvalue(y);
}

void tax() {
    x = a;
   
    zerocalc(x);
    signcalc(x);
}

void tay() {
    y = a;
   
    zerocalc(y);
    signcalc(y);
}

void tsx() {
    x = sp;
   
    zerocalc(x);
    signcalc(x);
}

void txa() {
    a = x;
   
    zerocalc(a);
    signcalc(a);
}

void txs() {
    sp = x;
}

void tya() {
    a = y;
   
    zerocalc(a);
    signcalc(a);
}

//undocumented instructions
#ifdef UNDOCUMENTED
    void lax() {
        lda();
        ldx();
    }

    void sax() {
        sta();
        stx();
        putvalue(a & x);
    }

    void dcp() {
        dec();
        cmp();
    }

    void isb() {
        inc();
        sbc();
    }

    void slo() {
        asl();
        ora();
    }

    void rla() {
        rol();
        op_and();
    }

    void sre() {
        lsr();
        eor();
    }

    void rra() {
        ror();
        adc();
    }
#else
    #define lax nop
    #define sax nop
    #define dcp nop
    #define isb nop
    #define slo nop
    #define rla nop
    #define sre nop
    #define rra nop
#endif


void nmi6502() {
    push16(pc);
    push8(cpustatus);
    cpustatus |= FLAG_INTERRUPT;
    pc = (uint16_t)read6502(0xFFFA) | ((uint16_t)read6502(0xFFFB) << 8);
}

void irq6502() {
    push16(pc);
    push8(cpustatus);
    cpustatus |= FLAG_INTERRUPT;
    pc = (uint16_t)read6502(0xFFFE) | ((uint16_t)read6502(0xFFFF) << 8);
}

#ifdef USE_TIMING
prog_char ticktable[256] PROGMEM = {
/*        |  0  |  1  |  2  |  3  |  4  |  5  |  6  |  7  |  8  |  9  |  A  |  B  |  C  |  D  |  E  |  F  |     */
/* 0 */      7,    6,    2,    8,    3,    3,    5,    5,    3,    2,    2,    2,    4,    4,    6,    6,  /* 0 */
/* 1 */      2,    5,    2,    8,    4,    4,    6,    6,    2,    4,    2,    7,    4,    4,    7,    7,  /* 1 */
/* 2 */      6,    6,    2,    8,    3,    3,    5,    5,    4,    2,    2,    2,    4,    4,    6,    6,  /* 2 */
/* 3 */      2,    5,    2,    8,    4,    4,    6,    6,    2,    4,    2,    7,    4,    4,    7,    7,  /* 3 */
/* 4 */      6,    6,    2,    8,    3,    3,    5,    5,    3,    2,    2,    2,    3,    4,    6,    6,  /* 4 */
/* 5 */      2,    5,    2,    8,    4,    4,    6,    6,    2,    4,    2,    7,    4,    4,    7,    7,  /* 5 */
/* 6 */      6,    6,    2,    8,    3,    3,    5,    5,    4,    2,    2,    2,    5,    4,    6,    6,  /* 6 */
/* 7 */      2,    5,    2,    8,    4,    4,    6,    6,    2,    4,    2,    7,    4,    4,    7,    7,  /* 7 */
/* 8 */      2,    6,    2,    6,    3,    3,    3,    3,    2,    2,    2,    2,    4,    4,    4,    4,  /* 8 */
/* 9 */      2,    6,    2,    6,    4,    4,    4,    4,    2,    5,    2,    5,    5,    5,    5,    5,  /* 9 */
/* A */      2,    6,    2,    6,    3,    3,    3,    3,    2,    2,    2,    2,    4,    4,    4,    4,  /* A */
/* B */      2,    5,    2,    5,    4,    4,    4,    4,    2,    4,    2,    4,    4,    4,    4,    4,  /* B */
/* C */      2,    6,    2,    8,    3,    3,    5,    5,    2,    2,    2,    2,    4,    4,    6,    6,  /* C */
/* D */      2,    5,    2,    8,    4,    4,    6,    6,    2,    4,    2,    7,    4,    4,    7,    7,  /* D */
/* E */      2,    6,    2,    8,    3,    3,    5,    5,    2,    2,    2,    2,    4,    4,    6,    6,  /* E */
/* F */      2,    5,    2,    8,    4,    4,    6,    6,    2,    4,    2,    7,    4,    4,    7,    7   /* F */
};
#endif

void exec6502(int32_t tickcount) {
#ifdef USE_TIMING
  clockgoal6502 += tickcount;
   
  while (clockgoal6502 > 0) {
#else
  while (tickcount--) {
#endif
    opcode = read6502(pc++);
    cpustatus |= FLAG_CONSTANT;

    useaccum = 0;

		switch (opcode) {
		case 0x0:
			imp();
			brk();
			break;
		case 0x1:
			indx();
			ora();
			break;
		case 0x5:
			zp();
			ora();
			break;
		case 0x6:
			zp();
			asl();
			break;
		case 0x8:
			imp();
			php();
			break;
		case 0x9:
			imm();
			ora();
			break;
		case 0xA:
			acc();
			asl();
			break;
		case 0xD:
			abso();
			ora();
			break;
		case 0xE:
			abso();
			asl();
			break;
		case 0x10:
			rel();
			bpl();
			break;
		case 0x11:
			indy();
			ora();
			break;
		case 0x15:
			zpx();
			ora();
			break;
		case 0x16:
			zpx();
			asl();
			break;
		case 0x18:
			imp();
			clc();
			break;
		case 0x19:
			absy();
			ora();
			break;
		case 0x1D:
			absx();
			ora();
			break;
		case 0x1E:
			absx();
			asl();
			break;
		case 0x20:
			abso();
			jsr();
			break;
		case 0x21:
			indx();
			op_and();
			break;
		case 0x24:
			zp();
			op_bit();
			break;
		case 0x25:
			zp();
			op_and();
			break;
		case 0x26:
			zp();
			rol();
			break;
		case 0x28:
			imp();
			plp();
			break;
		case 0x29:
			imm();
			op_and();
			break;
		case 0x2A:
			acc();
			rol();
			break;
		case 0x2C:
			abso();
			op_bit();
			break;
		case 0x2D:
			abso();
			op_and();
			break;
		case 0x2E:
			abso();
			rol();
			break;
		case 0x30:
			rel();
			bmi();
			break;
		case 0x31:
			indy();
			op_and();
			break;
		case 0x35:
			zpx();
			op_and();
			break;
		case 0x36:
			zpx();
			rol();
			break;
		case 0x38:
			imp();
			sec();
			break;
		case 0x39:
			absy();
			op_and();
			break;
		case 0x3D:
			absx();
			op_and();
			break;
		case 0x3E:
			absx();
			rol();
			break;
		case 0x40:
			imp();
			rti();
			break;
		case 0x41:
			indx();
			eor();
			break;
		case 0x45:
			zp();
			eor();
			break;
		case 0x46:
			zp();
			lsr();
			break;
		case 0x48:
			imp();
			pha();
			break;
		case 0x49:
			imm();
			eor();
			break;
		case 0x4A:
			acc();
			lsr();
			break;
		case 0x4C:
			abso();
			jmp();
			break;
		case 0x4D:
			abso();
			eor();
			break;
		case 0x4E:
			abso();
			lsr();
			break;
		case 0x50:
			rel();
			bvc();
			break;
		case 0x51:
			indy();
			eor();
			break;
		case 0x55:
			zpx();
			eor();
			break;
		case 0x56:
			zpx();
			lsr();
			break;
		case 0x58:
			imp();
			cli();
			break;
		case 0x59:
			absy();
			eor();
			break;
		case 0x5D:
			absx();
			eor();
			break;
		case 0x5E:
			absx();
			lsr();
			break;
		case 0x60:
			imp();
			rts();
			break;
		case 0x61:
			indx();
			adc();
			break;
		case 0x65:
			zp();
			adc();
			break;
		case 0x66:
			zp();
			ror();
			break;
		case 0x68:
			imp();
			pla();
			break;
		case 0x69:
			imm();
			adc();
			break;
		case 0x6A:
			acc();
			ror();
			break;
		case 0x6C:
			ind();
			jmp();
			break;
		case 0x6D:
			abso();
			adc();
			break;
		case 0x6E:
			abso();
			ror();
			break;
		case 0x70:
			rel();
			bvs();
			break;
		case 0x71:
			indy();
			adc();
			break;
		case 0x75:
			zpx();
			adc();
			break;
		case 0x76:
			zpx();
			ror();
			break;
		case 0x78:
			imp();
			sei();
			break;
		case 0x79:
			absy();
			adc();
			break;
		case 0x7D:
			absx();
			adc();
			break;
		case 0x7E:
			absx();
			ror();
			break;
		case 0x81:
			indx();
			sta();
			break;
		case 0x84:
			zp();
			sty();
			break;
		case 0x85:
			zp();
			sta();
			break;
		case 0x86:
			zp();
			stx();
			break;
		case 0x88:
			imp();
			dey();
			break;
		case 0x8A:
			imp();
			txa();
			break;
		case 0x8C:
			abso();
			sty();
			break;
		case 0x8D:
			abso();
			sta();
			break;
		case 0x8E:
			abso();
			stx();
			break;
		case 0x90:
			rel();
			bcc();
			break;
		case 0x91:
			indy();
			sta();
			break;
		case 0x94:
			zpx();
			sty();
			break;
		case 0x95:
			zpx();
			sta();
			break;
		case 0x96:
			zpy();
			stx();
			break;
		case 0x98:
			imp();
			tya();
			break;
		case 0x99:
			absy();
			sta();
			break;
		case 0x9A:
			imp();
			txs();
			break;
		case 0x9D:
			absx();
			sta();
			break;
		case 0xA0:
			imm();
			ldy();
			break;
		case 0xA1:
			indx();
			lda();
			break;
		case 0xA2:
			imm();
			ldx();
			break;
		case 0xA4:
			zp();
			ldy();
			break;
		case 0xA5:
			zp();
			lda();
			break;
		case 0xA6:
			zp();
			ldx();
			break;
		case 0xA8:
			imp();
			tay();
			break;
		case 0xA9:
			imm();
			lda();
			break;
		case 0xAA:
			imp();
			tax();
			break;
		case 0xAC:
			abso();
			ldy();
			break;
		case 0xAD:
			abso();
			lda();
			break;
		case 0xAE:
			abso();
			ldx();
			break;
		case 0xB0:
			rel();
			bcs();
			break;
		case 0xB1:
			indy();
			lda();
			break;
		case 0xB4:
			zpx();
			ldy();
			break;
		case 0xB5:
			zpx();
			lda();
			break;
		case 0xB6:
			zpy();
			ldx();
			break;
		case 0xB8:
			imp();
			clv();
			break;
		case 0xB9:
			absy();
			lda();
			break;
		case 0xBA:
			imp();
			tsx();
			break;
		case 0xBC:
			absx();
			ldy();
			break;
		case 0xBD:
			absx();
			lda();
			break;
		case 0xBE:
			absy();
			ldx();
			break;
		case 0xC0:
			imm();
			cpy();
			break;
		case 0xC1:
			indx();
			cmp();
			break;
		case 0xC4:
			zp();
			cpy();
			break;
		case 0xC5:
			zp();
			cmp();
			break;
		case 0xC6:
			zp();
			dec();
			break;
		case 0xC8:
			imp();
			iny();
			break;
		case 0xC9:
			imm();
			cmp();
			break;
		case 0xCA:
			imp();
			dex();
			break;
		case 0xCC:
			abso();
			cpy();
			break;
		case 0xCD:
			abso();
			cmp();
			break;
		case 0xCE:
			abso();
			dec();
			break;
		case 0xD0:
			rel();
			bne();
			break;
		case 0xD1:
			indy();
			cmp();
			break;
		case 0xD5:
			zpx();
			cmp();
			break;
		case 0xD6:
			zpx();
			dec();
			break;
		case 0xD8:
			imp();
			cld();
			break;
		case 0xD9:
			absy();
			cmp();
			break;
		case 0xDD:
			absx();
			cmp();
			break;
		case 0xDE:
			absx();
			dec();
			break;
		case 0xE0:
			imm();
			cpx();
			break;
		case 0xE1:
			indx();
			sbc();
			break;
		case 0xE4:
			zp();
			cpx();
			break;
		case 0xE5:
			zp();
			sbc();
			break;
		case 0xE6:
			zp();
			inc();
			break;
		case 0xE8:
			imp();
			inx();
			break;
		case 0xE9:
			imm();
			sbc();
			break;
		case 0xEB:
			imm();
			sbc();
			break;
		case 0xEC:
			abso();
			cpx();
			break;
		case 0xED:
			abso();
			sbc();
			break;
		case 0xEE:
			abso();
			inc();
			break;
		case 0xF0:
			rel();
			beq();
			break;
		case 0xF1:
			indy();
			sbc();
			break;
		case 0xF5:
			zpx();
			sbc();
			break;
		case 0xF6:
			zpx();
			inc();
			break;
		case 0xF8:
			imp();
			sed();
			break;
		case 0xF9:
			absy();
			sbc();
			break;
		case 0xFD:
			absx();
			sbc();
			break;
		case 0xFE:
			absx();
			inc();
			break;
		}
#ifdef USE_TIMING
      clockgoal6502 -= (int32_t)pgm_read_byte_near(ticktable + opcode);
#endif
      instructions++;
  }
}

uint16_t getpc() {
  return(pc);
}

uint8_t getop() {
  return(opcode);
}

