int w_colour=0x00; 
int w_black=0x01; 
int w_white =0x02; 
int w_blue=0x03; 
int w_green=0x04; 
int w_orange=0x05; 
int w_red=0x06; 
int w_yellow=0x07; 
int w_purple=0x08; 
int w_abort=0x09; 
int w_activate=0x0a; 
int w_begin=0x0b; 
int w_deactivate=0x0c; 
int w_destruct=0x0d; 
int w_go=0x0e; 
int w_move=0x0f; 
int w_off=0x10; 
int w_on=0x11; 
int w_open=0x12; 
int w_pull=0x13; 
int w_push=0x14; 
int w_reset=0x15; 
int w_run=0x16; 
int w_stop=0x17; 
int w_turn=0x18; 
int w_january=0x19; 
int w_february=0x1a; 
int w_march=0x1b; 
int w_april=0x1c; 
int w_may=0x1d; 
int w_june=0x1e; 
int w_july=0x1f; 
int w_august=0x20; 
int w_september=0x21; 
int w_october=0x22; 
int w_november=0x23; 
int w_december=0x24; 
int w_Monday=0x25; 
int w_Tuesday=0x26; 
int w_Wednesday=0x27; 
int w_Thursday=0x28; 
int w_Friday=0x29; 
int w_Saturday=0x2a; 
int w_Sunday=0x2b; 
int w_AM=0x2c; 
int w_PM=0x2d; 
int w_date=0x2e; 
int w_day=0x2f; 
int w_hours=0x30; 
int w_month=0x31; 
int w_oclock=0x32; 
int w_time=0x33; 
int w_week=0x34; 
int w_year=0x35; 
int w_zero=0x36; 
int w_one=0x37; 
int w_two=0x38; 
int w_three=0x39; 
int w_four=0x3a; 
int w_five=0x3b; 
int w_six=0x3c; 
int w_seven=0x3d; 
int w_eight=0x3e; 
int w_nine=0x3f; 
int w_ten=0x40; 
int w_eleven=0x41; 
int w_twelve=0x42; 
int w_thirteen=0x43; 
int w_fourteen=0x44; 
int w_fifteen=0x45; 
int w_sixteen=0x46; 
int w_seventeen=0x47; 
int w_eighteen=0x48; 
int w_nineteen=0x49; 
int w_twenty=0x4a; 
int w_thirty=0x4b; 
int w_forty=0x4c; 
int w_fifty=0x4d; 
int w_sixty=0x4e; 
int w_seventy=0x4f; 
int w_eighty=0x50; 
int w_ninety=0x51; 
int w_hundred=0x52; 
int w_thousand=0x53; 
int w_million=0x54; 
int w_north=0x55; 
int w_east=0x56; 
int w_south=0x57; 
int w_west=0x58; 
int w_up=0x59; 
int w_down=0x5a; 
int w_left=0x5b; 
int w_right=0x5c; 
int w_backward=0x5d; 
int w_forward=0x5e; 
int w_happy =0x5f; 
int w_sad=0x60; 
int w_angry=0x61; 
int w_AC=0x62; 
int w_amps=0x63; 
int w_celsius=0x64; 
int w_centi=0x65; 
int w_cubic=0x66; 
int w_DC=0x67; 
int w_degrees=0x68; 
int w_diameter=0x69; 
int w_fahrenheit=0x6a; 
int w_farads=0x6b; 
int w_feet=0x6c; 
int w_frequency=0x6d; 
int w_giga=0x6e; 
int w_gram=0x6f; 
int w_height=0x70; 
int w_hertz=0x71; 
int w_humidity=0x72; 
int w_inches=0x73; 
int w_kilo=0x74; 
int w_length=0x75; 
int w_light=0x76; 
int w_litre=0x77; 
int w_mega=0x78; 
int w_meters=0x79; 
int w_micro=0x7a; 
int w_milli=0x7b; 
int w_minutes=0x7c; 
int w_nano=0x7d; 
int w_newton=0x7e; 
int w_night=0x7f; 
int w_ohms=0x80; 
int w_per=0x81; 
int w_pico=0x82; 
int w_pitch=0x83; 
int w_pounds=0x84; 
int w_radius=0x85; 
int w_rate=0x86; 
int w_seconds=0x87; 
int w_sound=0x88; 
int w_speed=0x89; 
int w_temperature=0x8a; 
int w_volts=0x8b; 
int w_watts=0x8c; 
int w_weight=0x8d; 
int w_alarm=0x8e; 
int w_alert=0x8f; 
int w_detected=0x90; 
int w_intruder=0x91; 
int w_security=0x92; 
int w_system=0x93; 
int w_warning=0x94; 
int w_clockwise=0x95; 
int w_counter=0x96; 
int w_divide=0x97; 
int w_equals=0x98; 
int w_minus=0x99; 
int w_multiply=0x9a; 
int w_not=0x9b; 
int w_plus=0x9c; 
int w_squareroot=0x9d; 
int w_A=0x9e; 
int w_ahead=0x9f; 
int w_air=0xa0; 
int w_altitude=0xa1; 
int w_an=0xa2; 
int w_am=0xa3; 
int w_and=0xa4; 
int w_are=0xa5; 
int w_area=0xa6; 
int w_at=0xa7; 
int w_axis=0xa8; 
int w_back =0xa9; 
int w_be =0xaa; 
int w_bearing=0xab; 
int w_been=0xac; 
int w_button=0xad; 
int w_by=0xae; 
int w_can=0xaf; 
int w_caution=0xb0; 
int w_change=0xb1; 
int w_check=0xb2; 
int w_closed=0xb3; 
int w_condition=0xb4; 
int w_contact=0xb5; 
int w_critical=0xb6; 
int w_door=0xb7; 
int w_empty=0xb8; 
int w_end=0xb9; 
int w_environment=0xba; 
int w_falling=0xbb; 
int w_fast=0xbc; 
int w_fatal=0xbd; 
int w_feel=0xbe; 
int w_first=0xbf; 
int w_from=0xc0; 
int w_front=0xc1; 
int w_going=0xc2; 
int w_goodbye=0xc3; 
int w_he =0xc4; 
int w_hello=0xc5; 
int w_high=0xc6; 
int w_how=0xc7; 
int w_I=0xc8; 
int w_in =0xc9; 
int w_incoming=0xca; 
int w_ing=0xcb; 
int w_inside=0xcc; 
int w_is=0xcd; 
int w_it=0xce; 
int w_laser=0xcf; 
int w_last=0xd0; 
int w_level=0xd1; 
int w_locked=0xd2; 
int w_low=0xd3; 
int w_me=0xd4; 
int w_message=0xd5; 
int w_mode=0xd6; 
int w_motor=0xd7; 
int w_new=0xd8; 
int w_next=0xd9; 
int w_nomincal=0xda; 
int w_object=0xdb; 
int w_obstacle=0xdc; 
int w_of=0xdd; 
int w_out=0xde; 
int w_outside=0xdf; 
int w_press=0xe0; 
int w_process=0xe1; 
int w_purge=0xe2; 
int w_range=0xe3; 
int w_rear=0xe4; 
int w_received=0xe5; 
int w_rising=0xe6; 
int w_sent=0xe7; 
int w_sequence=0xe8; 
int w_she=0xe9; 
int w_sleep=0xea; 
int w_slow=0xeb; 
int w_stable=0xec; 
int w_start=0xed; 
int w_step=0xee; 
int w_stepper=0xef; 
int w_switch=0xf0; 
int w_tell=0xf1; 
int w_the=0xf2; 
int w_there=0xf3; 
int w_they=0xf4; 
int w_to =0xf5; 
int w_total=0xf6; 
int w_vent=0xf7; 
// int w_warning=0xf8; 
int w_we =0xf9; 
int w_will=0xfa; 
int w_window=0xfb; 
int w_you=0xfc; 
int w_zone=0xfd;

//Setup 
#include <SPI.h>    // include the SPI communcation library
// Connect pin#13 (SCLK) To S2 on AP23 
// Connect pin#11 (DATOUT) To S3 on AP23 
// Connect pin#13 (SCLK) To S2 on AP23 
// Connect pin#10 (CS) To S1 on AP23
// GPIO 9 = STOP
// DO from Ap23 optional S4 - Not used here
// ** Add stop bit so that MCU knows then  the chip has stopped talking.  OUT1 is what you'll want to use
#define STOP 9      // The STOP wire is the busy signal of the 
#define PLAY 0x98
#define RAMPUP 0xA8 //COUT ramp up - this value never changes
#define RAMPDOWN 0xB8 //COUT ram down
int cs = 10;

int sentence[] = {w_one, w_two, w_three, w_four};
int sentence2[] = {w_red, w_alert, w_red, w_alert, w_intruder, w_alert};

void setup() {
  // put your setup code here, to run once:
 pinMode(STOP,INPUT);     // Set the "STOP" GPIO as an input.  This is the busy signal, and is high when the shield is busy playing a word
  SPI.begin();             // Initialize SPI
  SPI.setClockDivider(SPI_CLOCK_DIV32); // low frequency SPI
  pinMode(cs,OUTPUT);    // Chip select pins is an output
  digitalWrite(cs,HIGH); // Set chip select to be HIGH (5v) by default.  The chip on the shield is selected when this line is brought low. 
  SPI.setBitOrder(MSBFIRST);  // OTP requires MSB first
  SPI.setDataMode(SPI_MODE0);  // Use MODE0, as all other modes to not work
  delay(1000);   // One second delay
  Serial.begin(9600);
}

#define arr_len( x ) ( sizeof ( x ) / sizeof (*x) )

void loop() {
  Serial.println(arr_len(sentence));
  // put your main code here, to run repeatedly:
for (int i = 0; i < arr_len(sentence); i++) {
  say(sentence[i]);
}

delay(1000);
 Serial.println(arr_len(sentence2));
  // put your main code here, to run repeatedly:
for (int i = 0; i < arr_len(sentence2); i++) {
  say(sentence2[i]);
}

for (int i = w_colour; i < w_zone; i++) {
  say(i);
}

Serial.println(0xfd);
while(1);

//say(red);
//delay(100);
//say(alert);
//delay(1000);
//say(red);
//delay(100);
//say(alert);
delay(1000);
}

void say(int value)    // Calling this function reads words individually
{
  // ramp up
  digitalWrite(cs,LOW);
  SPI.transfer(RAMPUP);
  SPI.transfer(0x00);
  digitalWrite(cs,HIGH);
  delay(7);
  // Transmit Data
  digitalWrite(cs,LOW);
  SPI.transfer(PLAY);
  SPI.transfer(value);
  digitalWrite(cs,HIGH);
  delay(5);
  while (digitalRead(STOP) == HIGH) { 
       {}
    } 
  //delay(5);
  // ramp down
  digitalWrite(cs,LOW);
  SPI.transfer(RAMPDOWN);
  SPI.transfer(0x00);
  digitalWrite(cs,HIGH);
  delay(10);
  // YOU REALLY NEED TO ADD A STOP INPUT HERE, OR ELSE YOU'RE REALLY WASTING POWER!
}


